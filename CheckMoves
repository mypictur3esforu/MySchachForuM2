public class CheckMoves {
    public static int[] secondMover = new int[2];
    public static int[][] rooks = new int[][]{{0, 1000},{7, 1000}, {56, 1000}, {63, 1000}};
    public static boolean CheckMove(int isOnSquare, int moveToSquare){
        boolean temporary = true;
        switch (Usefull.GetSquaresPieceNotation(isOnSquare)){
            case "R" -> {temporary = CheckColumRow(isOnSquare, moveToSquare); HandleRookMove(isOnSquare, temporary); }
            case "N" -> {temporary = CheckLMovement(isOnSquare, moveToSquare);}
            case "B" -> {temporary = CheckDiagonal(isOnSquare, moveToSquare);}
            case "Q" -> {temporary = CheckColumRow(isOnSquare, moveToSquare) || CheckDiagonal(isOnSquare, moveToSquare); }
            case "K" -> {temporary = CheckSurround(isOnSquare, moveToSquare) || CheckCastle(isOnSquare, moveToSquare);}
        }
        if (!temporary || !CheckIfPinned(isOnSquare, moveToSquare)) {
            return false;
        }
        return CheckIfPieceCanBeTaken(isOnSquare, moveToSquare);
    }

    static boolean CheckIfPinned(int isOnSquare, int moveToSquare){
        return true;
    }

    static boolean CheckIfPieceCanBeTaken(int isOnSquare, int moveToSquare){
        if(Usefull.GetColorOfSquaresPiece(isOnSquare).equals(Usefull.GetColorOfSquaresPiece(moveToSquare))){
            System.out.println("You can not take your own pieces!");
            return false;
        }
        return true;
    }

    static void HandleRookMove(int isOnSquare, boolean moveLegal){
        if (!moveLegal) {
            return;
        }
        for (int i = 0; i < rooks.length; i++) {
            if (rooks[i][0] == isOnSquare) {
                rooks[i][1] = 0;
            }
        }
    }

    static boolean CheckColumRow(int isOnSquare, int moveToSquare){
        String movement = CheckIfColumOrRowMovement(isOnSquare, moveToSquare);
        if (movement.equals("false")) {
            System.out.println("The chosen piece is not allowed to go there! (" + movement + ")");
            return false;
        }
        if (movement.equals("row")) {
            if(!CheckIfPieceIsInBetween(isOnSquare, moveToSquare, 1)){
                return false;
            }
        }
        if (movement.equals("column")) {
            return CheckIfPieceIsInBetween(isOnSquare, moveToSquare, 8);
        }
        return true;
    }

    static String CheckIfColumOrRowMovement(int isOnSquare, int moveToSquare){
        if (Math.abs(moveToSquare - isOnSquare) < 8 ) {
            return "row";
        }
        if (Math.abs(moveToSquare - isOnSquare) % 8 == 0) {
            return "column";
        }
        return "false";
    }

    static boolean CheckDiagonal(int isOnSquare, int moveToSquare){
        int movement = CheckWhichDiagonal(isOnSquare, moveToSquare);
        if (movement == 0) {
            System.out.println("This piece is not able to go there! (diagonally)");
            return false;
        }
        return CheckIfPieceIsInBetween(isOnSquare, moveToSquare, movement);
    }

    static int CheckWhichDiagonal(int isOnSquare, int moveToSquare){
        int movement = 1;
        /*if (isOnSquare > moveToSquare) {
            movement *= -1;
        }*/
        if (Math.abs(moveToSquare - isOnSquare) % 7 == 0) {
            return movement * 7;
        }
        if (Math.abs(moveToSquare - isOnSquare) % 9 == 0) {
            return movement * 9;
        }
        return 0;
    }

    static boolean CheckLMovement(int isOnSquare, int moveToSquare){
        int[] possibleSquares = new int[]{6, 10, 15, 17};
        int direction = 1;
        for (int z = 0; z <= 1; z++) {
            for (int i = 0; i < possibleSquares.length; i++) {
                if (isOnSquare + possibleSquares[i] * direction == moveToSquare) {
                    return true;
                }
            }
            direction *= -1;
        }
        System.out.println("This Knight is not able to go to chosen square! (l movement)");
        return false;
    }

    static boolean CheckSurround(int isOnSquare, int moveToSquare){
        int[] possibleSquares = new int[]{1, 7, 8, 9};
        int direction = 1;
        for (int z = 0; z <= 1; z++) {
            for (int i = 0; i < possibleSquares.length; i++) {
                if (isOnSquare + possibleSquares[i] * direction == moveToSquare) {
                    return true;
                }
            }
            direction *= -1;
        }
        System.out.println("The King is not able to go to chosen square! (surround movement)");
        return false;
    }

    static boolean CheckCastle(int isOnSquare, int moveToSquare){
        int direction = 1;
        if (isOnSquare > moveToSquare) {
            direction *= -1;
        }
        if (Math.abs(moveToSquare - isOnSquare) != 2 || !CheckIfPieceIsInBetween(isOnSquare, moveToSquare + 1, 1)){
            System.out.println("That is not how Castling works!");
            return false;
        }
        for (int i = 0; i <= 2; i++) {
            if (!FindCheck.CheckForChecks(isOnSquare + (i * direction))) {
                return false;
            }
        }
        System.out.println("Castling allowed");
        return RookInPlace(isOnSquare, direction);
    }

    static boolean RookInPlace(int isOnSquare, int direction){
        int[] rookSquares = new int[]{0, 7, 56, 63};
        int fieldToSearch = -1, distance = 100;
        for (int i = 0; i < rookSquares.length; i++) {
            if (Math.abs(isOnSquare - rookSquares[i]) < distance) {
                distance = Math.abs(isOnSquare - rookSquares[i]);
                fieldToSearch = rookSquares[i];
            }
        }
        for (int i = 0; isOnSquare + (i * direction) != fieldToSearch + direction; i++) {
            String[] tempSquare = Usefull.CreateFieldValueArray(isOnSquare + ( i * direction));
            if (tempSquare.length == 1) {
                continue;
            }
            if (Usefull.CreateFieldValueArray(isOnSquare + (i*direction))[1].equals("R")) {
                for (int j = 0; j < rooks.length; j++) {
                    if (rooks[j][0] == isOnSquare + (i * direction)) {
                        if (rooks[j][1] == 0) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    static boolean CheckIfPieceIsInBetween(int isOnSquare, int moveToSquare, int movement){
        if (isOnSquare > moveToSquare) {
            movement *= -1;
        }
        for (int i = 0; isOnSquare != moveToSquare - movement; isOnSquare += movement) {
            if (!Court.court[i].equals("0")) {
                System.out.println("There is a piece in the way! Movement: " + movement);
                return false;
            }
        }
        return true;
    }

}
